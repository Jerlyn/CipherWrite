/**
 * AI Text Detector
 * 
 * This module implements a simple AI-generated text detection algorithm
 * based on statistical analysis of text patterns.
 */

class AITextDetector {
  constructor() {
    // Initialize features that will be used for detection
    this.features = {
      // Common AI text patterns - optimized for performance
      repetitivePatterns: [
        /\b(\w+)\b(?:\s+(?:\w+)\s+){0,3}\b\1\b/gi, // Nearby word repetition - simplified
        /\b(\w{7,})\b(?:[\s\S]{0,500})\b\1\b/gi,   // Long word repetition - limited scope
        /\b(?:in conclusion|to summarize|overall|thus)\b/gi // Common AI transition phrases
      ],
      
      // Sentence structure patterns
      sentencePatterns: [
        /\b(?:however|nevertheless|moreover|furthermore|therefore|consequently|thus)\b/gi, // Formal transitions
        /\b(?:it is \w+ that|it is worth noting that|it is important to \w+ that)\b/gi, // Formal constructions
        /\b(?:as we can see|we can observe that|it is evident that|it is clear that)\b/gi // Academic phrases
      ],
      
      // Diversity of punctuation - simplified
      punctuationDiversity: /[,.;:!?()[\]{}""''—–-]/g,
      
      // Balance of passive/active voice (approximation) - simplified
      passiveVoicePatterns: /\b(?:is|are|was|were|be|been|being)\s+\w+ed\b/gi,
      
      // Human style markers - simplified
      humanStyleMarkers: [
        /\b(?:I think|I believe|I feel|in my opinion)\b/gi, // Personal opinions
        /\b(?:like|basically|actually|literally|honestly|just)\b/gi, // Filler words
        /\b(?:gonna|wanna|sorta|kinda|y'know)\b/gi, // Informal contractions
        /\b(?:awesome|cool|great|weird|crazy|ridiculous)\b/gi, // Colloquial adjectives
        /(?:!{2,}|\?{2,}|\.{3,})/g, // Multiple punctuation
        /\b(?:BTW|LOL|IMHO|TBH)\b/gi // Internet abbreviations
      ]
    };
    
    // Confidence thresholds
    this.thresholds = {
      highConfidence: 80,
      mediumConfidence: 60,
      lowConfidence: 40
    };
  }
  
  /**
   * Analyzes text to determine if it was likely generated by AI
   * @param {string} text - The text to analyze
   * @returns {object} Analysis results with probability score and confidence
   */
  analyze(text) {
    // Validate input
    if (!text || typeof text !== 'string') {
      return {
        score: 0,
        confidence: 'insufficient',
        explanation: 'Cannot analyze empty or invalid text.'
      };
    }
    
    // Check if text is long enough for reliable analysis
    if (text.length < 100) {
      return {
        score: 0,
        confidence: 'insufficient',
        explanation: 'Text is too short for reliable analysis. Please provide at least 100 characters.'
      };
    }
    
    // Limit text length to prevent browser hanging
    const maxLength = 10000; // 10K characters max
    if (text.length > maxLength) {
      text = text.substring(0, maxLength);
    }

    try {
      // Calculate scores from different features with timeout protection
      const scores = {
        repetitivePatterns: this.calculateRepetitivePatternScore(text),
        sentenceStructure: this.calculateSentenceStructureScore(text),
        punctuationDiversity: this.calculatePunctuationDiversityScore(text),
        passiveVoice: this.calculatePassiveVoiceScore(text),
        humanStyle: this.calculateHumanStyleScore(text)
      };
      
      // Calculate weighted average score
      const weights = {
        repetitivePatterns: 0.20,
        sentenceStructure: 0.20,
        punctuationDiversity: 0.15,
        passiveVoice: 0.15,
        humanStyle: 0.30
      };
      
      // Start with a neutral baseline (50%)
      let baselineScore = 50;
      let totalScore = baselineScore;
      let totalWeight = 1; // Starting with weight of 1 for the baseline
      
      for (const [feature, weight] of Object.entries(weights)) {
        totalScore += (scores[feature] - baselineScore) * weight;
        totalWeight += weight;
      }
      
      // Ensure probability is capped at 100% and has a minimum of 0%
      const aiProbability = Math.min(100, Math.max(0, Math.round(totalScore / totalWeight)));
      
      // Determine confidence level
      let confidence = 'low';
      if (aiProbability >= this.thresholds.highConfidence || aiProbability <= (100 - this.thresholds.highConfidence)) {
        confidence = 'high';
      } else if (aiProbability >= this.thresholds.mediumConfidence || aiProbability <= (100 - this.thresholds.mediumConfidence)) {
        confidence = 'medium';
      }
      
      // Generate explanation
      const explanation = this.generateExplanation(aiProbability, scores);
      
      return {
        score: aiProbability,
        confidence,
        explanation,
        details: scores
      };
    } catch (error) {
      console.error("Analysis error:", error);
      return {
        score: 50,
        confidence: 'low',
        explanation: 'Analysis encountered an error. Please try with different text.',
        details: {}
      };
    }
  }
  
  /**
   * Calculates score for repetitive patterns (common in AI text)
   * @param {string} text - Text to analyze
   * @returns {number} Score between 0-100
   */
  calculateRepetitivePatternScore(text) {
    let count = 0;
    
    // Process in smaller chunks to prevent regex timeout
    const chunkSize = 1000;
    const chunks = Math.ceil(text.length / chunkSize);
    
    for (let i = 0; i < chunks; i++) {
      const chunk = text.substring(i * chunkSize, (i + 1) * chunkSize);
      
      this.features.repetitivePatterns.forEach(pattern => {
        const matches = chunk.match(pattern) || [];
        count += matches.length;
      });
    }
    
    // Normalize based on text length with a safety cap
    const textLengthFactor = Math.max(1, text.length / 500);
    const normalizedCount = Math.min(1.25, count / textLengthFactor);
    
    // Convert to score - more repetition means higher AI probability
    return Math.min(100, Math.max(0, normalizedCount * 40 + 50));
  }
  
  /**
   * Calculates score for sentence structure patterns
   * @param {string} text - Text to analyze
   * @returns {number} Score between 0-100
   */
  calculateSentenceStructureScore(text) {
    let count = 0;
    
    // Process in smaller chunks to prevent regex timeout
    const chunkSize = 1000;
    const chunks = Math.ceil(text.length / chunkSize);
    
    for (let i = 0; i < chunks; i++) {
      const chunk = text.substring(i * chunkSize, (i + 1) * chunkSize);
      
      this.features.sentencePatterns.forEach(pattern => {
        const matches = chunk.match(pattern) || [];
        count += matches.length;
      });
    }
    
    // Split into sentences - using a simpler approach
    const sentences = text.split(/[.!?]+/);
    const validSentences = sentences.filter(s => s.trim().length > 0);
    
    // Calculate ratio of formal constructions to total sentences
    const ratio = validSentences.length > 0 ? count / validSentences.length : 0;
    
    // Ensure ratio is reasonable (cap at 0.5 to prevent unreasonably high scores)
    const normalizedRatio = Math.min(0.5, ratio);
    
    // Convert to score - more formal constructions means higher AI probability
    return Math.min(100, Math.max(0, normalizedRatio * 120 + 40));
  }
  
  /**
   * Calculates score for punctuation diversity
   * @param {string} text - Text to analyze
   * @returns {number} Score between 0-100
   */
  calculatePunctuationDiversityScore(text) {
    // Sample the text to prevent excessive processing
    const sampleText = text.length > 2000 ? 
      text.substring(0, 1000) + text.substring(text.length - 1000) : 
      text;
    
    const punctuation = sampleText.match(this.features.punctuationDiversity) || [];
    const uniquePunctuation = new Set(punctuation).size;
    
    // Ensure we have enough punctuation for analysis
    if (punctuation.length < 5) {
      return 50; // Return neutral score for insufficient data
    }
    
    // Calculate diversity ratio
    const ratio = uniquePunctuation / punctuation.length;
    
    // Bound ratio between 0 and 1
    const boundedRatio = Math.min(1, Math.max(0, ratio));
    
    // Convert to score - less diversity means higher AI probability
    return Math.min(100, Math.max(0, (1 - boundedRatio) * 70 + 30));
  }
  
  /**
   * Calculates score for passive voice usage
   * @param {string} text - Text to analyze
   * @returns {number} Score between 0-100
   */
  calculatePassiveVoiceScore(text) {
    // Sample the text to prevent excessive processing
    const sampleText = text.length > 3000 ? 
      text.substring(0, 1500) + text.substring(text.length - 1500) : 
      text;
    
    const passiveCount = (sampleText.match(this.features.passiveVoicePatterns) || []).length;
    
    // Split into sentences - using a simpler approach
    const sentences = sampleText.split(/[.!?]+/);
    const validSentences = sentences.filter(s => s.trim().length > 0);
    
    // Handle insufficient data
    if (validSentences.length < 3) {
      return 50; // Return neutral score
    }
    
    // Calculate ratio of passive voice to total sentences
    const ratio = passiveCount / validSentences.length;
    
    // Cap ratio at a reasonable maximum (0.4 - rare to have more than 40% passive sentences)
    const cappedRatio = Math.min(0.4, ratio);
    
    // Convert to score - more passive voice means higher AI probability
    return Math.min(100, Math.max(0, cappedRatio * 150 + 35));
  }
  
  /**
   * Calculates score for human writing style markers
   * @param {string} text - Text to analyze
   * @returns {number} Score between 0-100 (lower score means more human-like)
   */
  calculateHumanStyleScore(text) {
    let count = 0;
    
    // Process in smaller chunks to prevent regex timeout
    const chunkSize = 1000;
    const chunks = Math.ceil(text.length / chunkSize);
    
    for (let i = 0; i < chunks; i++) {
      const chunk = text.substring(i * chunkSize, (i + 1) * chunkSize);
      
      this.features.humanStyleMarkers.forEach(pattern => {
        const matches = chunk.match(pattern) || [];
        count += matches.length;
      });
    }
    
    // Check for unique/varied sentence lengths (human writers tend to vary sentence length)
    // Use a sampling approach for performance
    const sampleText = text.length > 3000 ? 
      text.substring(0, 1500) + text.substring(text.length - 1500) : 
      text;
    
    const sentences = sampleText.split(/[.!?]+/).filter(s => s.trim().length > 0);
    
    // Take a sample of sentences if there are too many
    const maxSentences = 50;
    const sentenceSample = sentences.length > maxSentences ? 
      sentences.filter((_, i) => i % Math.ceil(sentences.length / maxSentences) === 0) : 
      sentences;
    
    const sentenceLengths = sentenceSample.map(s => s.split(/\s+/).length);
    
    // Calculate sentence length variance if we have multiple sentences
    let lengthVariance = 0;
    if (sentenceLengths.length > 1) {
      const meanLength = sentenceLengths.reduce((sum, len) => sum + len, 0) / sentenceLengths.length;
      lengthVariance = sentenceLengths.reduce((sum, len) => sum + Math.pow(len - meanLength, 2), 0) / sentenceLengths.length;
    }
    
    // Normalize based on text length with safety bounds
    const textLengthFactor = Math.max(1, text.length / 500);
    const normalizedCount = Math.min(3, count / textLengthFactor);
    
    // Convert to score - more human markers means lower AI probability
    // Base score from human markers
    let score = Math.max(0, 75 - (normalizedCount * 20));
    
    // Add influence from sentence length variance (higher variance = more human-like)
    if (lengthVariance > 5) {
      score = Math.max(0, score - 15); // Significantly reduce AI score for highly varied sentence lengths
    } else if (lengthVariance > 2) {
      score = Math.max(0, score - 10); // Moderately reduce AI score for somewhat varied sentence lengths
    }
    
    return score;
  }
  
  /**
   * Generates explanation text based on analysis results
   * @param {number} score - Final AI probability score
   * @param {object} details - Score details for each feature
   * @returns {string} Human-readable explanation
   */
  generateExplanation(score, details) {
    let explanation = '';
    
    if (score >= 80) {
      explanation = 'This text shows strong indicators of AI generation. ';
    } else if (score >= 60) {
      explanation = 'This text shows moderate indicators of AI generation. ';
    } else if (score >= 40) {
      explanation = 'This text shows mixed indicators with both AI and human characteristics. ';
    } else {
      explanation = 'This text shows characteristics typically associated with human writing. ';
    }
    
    // Add feature-specific insights (max 2 for clarity)
    const sortedFeatures = Object.entries(details).sort((a, b) => b[1] - a[1]);
    const highestFeature = sortedFeatures[0];
    
    if (highestFeature[1] >= 70) {
      explanation += this.getFeatureExplanation(highestFeature[0], true);
    }
    
    // Add confidence level explanation
    explanation += ' ' + this.getConfidenceExplanation(score, details);
    
    return explanation;
  }
  
  /**
   * Generates an explanation of the confidence level
   * @param {number} score - Overall AI probability score
   * @param {object} details - Score details for each feature
   * @returns {string} Confidence explanation
   */
  getConfidenceExplanation(score, details) {
    // Calculate the standard deviation of scores to determine confidence
    const scores = Object.values(details);
    const mean = scores.reduce((sum, val) => sum + val, 0) / scores.length;
    const squaredDiffs = scores.map(score => Math.pow(score - mean, 2));
    const variance = squaredDiffs.reduce((sum, val) => sum + val, 0) / scores.length;
    const stdDev = Math.sqrt(variance);
    
    // Create appropriate explanation based on confidence level
    if (stdDev > 25) {
      return 'Analysis shows varied indicators across different assessment factors.';
    } else if ((score > 75 || score < 25) && stdDev < 15) {
      return 'Multiple consistent indicators across assessment factors support this result.';
    } else {
      return 'This assessment represents a balanced analysis of the available text patterns.';
    }
  }
  
  /**
   * Gets explanation text for a specific feature
   * @param {string} feature - Feature name
   * @param {boolean} isHigh - Whether the score is high
   * @returns {string} Feature-specific explanation
   */
  getFeatureExplanation(feature, isHigh) {
    const explanations = {
      repetitivePatterns: {
        high: 'The text contains recurring phrases and word patterns that are statistically more common in AI-generated content.',
        low: 'The text avoids repetition in a way that suggests human authorship.'
      },
      sentenceStructure: {
        high: 'The text uses formal transitions and academic-style constructions frequently seen in AI writing.',
        low: 'The text has varied and natural sentence structures more typical of human writing.'
      },
      punctuationDiversity: {
        high: 'The text shows limited variety in punctuation usage commonly observed in AI-generated content.',
        low: 'The text displays natural punctuation patterns typical of human writing.'
      },
      passiveVoice: {
        high: 'The text contains a proportion of passive voice constructions that correlates with AI writing patterns.',
        low: 'The text shows a natural balance of active and passive voice typical of human writing.'
      },
      humanStyle: {
        high: 'The text lacks conversational elements, varying sentence lengths, and personal expressions common in human writing.',
        low: 'The text contains natural human elements like conversational phrases, varied sentence lengths, and personal expressions.'
      }
    };
    
    return explanations[feature][isHigh ? 'high' : 'low'];
  }
}